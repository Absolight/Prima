#define map_RGB_gray ((Byte*)std256gray_palette)
static Byte     map_stdcolorref    [ 256];
static Byte     div51              [ 256];
static Byte     div17              [ 256];
static Byte     mod51              [ 256];
static Byte     mod17mul3          [ 256];
static RGBColor cubic_palette      [ 256];
static RGBColor cubic_palette8     [   8];
static RGBColor cubic_palette16    [  16] =
{
   {0,0,0}, {0,128,128}, {128,0,128}, {0,0,255},
   {128,128,0}, {0,255,0}, {255,0,0}, {85,85,85},
   {170,170,170},{0,255,255},{255,0,255},{128,128,255},
   {255,255,0},{128,255,128},{255,128,128},{255,255,255}
};
static RGBColor stdmono_palette    [   2] = {{ 0, 0, 0}, { 0xFF, 0xFF, 0xFF}};
static RGBColor std16gray_palette  [  16];
static RGBColor std256gray_palette [ 256];
static Byte     map_halftone8x8_51 [  64] = {
    0, 38,  9, 47,  2, 40, 11, 50,
   25, 12, 35, 22, 27, 15, 37, 24,
    6, 44,  3, 41,  8, 47,  5, 43,
   31, 19, 28, 15, 34, 21, 31, 18,
    1, 39, 11, 49,  0, 39, 10, 48,
   27, 14, 36, 23, 26, 13, 35, 23,
    7, 46,  4, 43,  7, 45,  3, 42,
   33, 20, 30, 17, 32, 19, 29, 16
};
static Byte     map_halftone8x8_64 [  64] = {
    0, 47, 12, 59,  3, 50, 15, 62,
   32, 16, 43, 28, 34, 19, 46, 31,
    8, 55,  4, 51, 11, 58,  7, 54,
   39, 24, 35, 20, 42, 27, 38, 23,
    2, 49, 14, 61,  1, 48, 13, 60,
   33, 18, 45, 30, 32, 17, 44, 29,
   10, 57,  6, 53,  9, 56,  5, 52,
   41, 26, 37, 22, 40, 25, 36, 21
};

static void
cm_init_colormap()
{
   int i;
   for ( i = 0; i < 256; i++)
   {
      map_RGB_gray[ i * 3] = map_RGB_gray[ i * 3 + 1] = map_RGB_gray[ i * 3 + 2] = i;
      map_stdcolorref[ i] = i;
      div51[ i] = i / 51;
      div17[ i] = i / 17;
      mod51[ i] = i % 51;
      mod17mul3[ i] = ( i % 17) * 3;
   }
   for ( i = 0; i < 16; i++)
      std16gray_palette[ i]. r = std16gray_palette[ i]. g = std16gray_palette[ i]. b = i * 17;
   {
      int b, g, r;
      for ( b = 0; b < 6; b++) for ( g = 0; g < 6; g++) for ( r = 0; r < 6; r++)
      {
//       cubic_palette[ b + g * 6 + r * 36] =( RGBColor) { b * 51, g * 51, r * 51 };
	 int idx = b + g * 6 + r * 36;
	 cubic_palette[ idx]. b = b * 51;
	 cubic_palette[ idx]. g = g * 51;
	 cubic_palette[ idx]. r = r * 51;
      }
   }
   {
      int b, g, r;
      for ( b = 0; b < 2; b++) for ( g = 0; g < 2; g++) for ( r = 0; r < 2; r++)
      {
//       cubic_palette8[ b + g * 2 + r * 4] = ( RGBColor) { b * 255, g * 255, r * 255 };
	 int idx = b + g * 2 + r * 4;
	 cubic_palette8[ idx]. b = b * 255;
	 cubic_palette8[ idx]. g = g * 255;
	 cubic_palette8[ idx]. r = r * 255;
      }
   }
}

static void
cm_reverse_palette( PRGBColor source, PRGBColor dest, int colors)
{
   while( colors--)
   {
      register Byte r = source[0].r;
      register Byte b = source[0].b;
      register Byte g = source[0].g;
      dest[0].r = b;
      dest[0].b = r;
      dest[0].g = g;
      source++;
      dest++;
   }
}

static void
cm_squeeze_palette( PRGBColor source, int srcColors, PRGBColor dest, int destColors)
{
   if (( srcColors == 0) || ( destColors == 0)) return;
   if ( srcColors <= destColors)
      memcpy( dest, source, srcColors * sizeof( RGBColor));
   else
   {
      int tolerance = 0;
      int colors    = srcColors;
      PRGBColor buf = ( PRGBColor) malloc( srcColors * sizeof( RGBColor));
      memcpy( buf, source, srcColors * sizeof( RGBColor));
      while ( colors > destColors)
      {
         int i;
         for ( i = 0; i < colors; i++)
         {
            RGBColor r = buf[ i];
            if ( i < colors - 1)
            {
               int j;
               int k = i + 1;
               PRGBColor next = &buf[ k];
               for ( j = i + 1; j < colors; j++)
               {
                  if (( abs( next[0].r - r.r) +
                        abs( next[0].g - r.g) +
                        abs( next[0].b - r.b)) <= tolerance)
                  {
                     if ( colors == destColors) goto Enough;
                     if ( j >= colors) break;
                     buf[ k] = buf[ --colors];
                  }
                  next++;
                  k++;
               }
            }
         }
         tolerance++;
      }
Enough:
      memcpy( dest, buf, destColors * sizeof( RGBColor));
      free( buf);
   }
}

Byte
cm_nearest_color( RGBColor color, int palSize, PRGBColor palette)
{
   int diff = 0x10000, cdiff = 0;
   Byte ret = 0;
   while( palSize--)
   {
      int dr=abs( (int)color. r - (int)palette[ palSize]. r),
          dg=abs( (int)color. g - (int)palette[ palSize]. g),
          db=abs( (int)color. b - (int)palette[ palSize]. b);
      cdiff=dr*dr+dg*dg+db*db;
      if ( cdiff < diff)
      {
         ret = palSize;
         diff = cdiff;
         if ( cdiff == 0) break;
      }
   }
   return ret;
}

void
cm_fill_colorref( PRGBColor fromPalette, int fromColorCount, PRGBColor toPalette, int toColorCount, Byte * colorref)
{
   while( fromColorCount--)
      colorref[ fromColorCount] =
         cm_nearest_color( fromPalette[ fromColorCount], toColorCount, toPalette);
}

#define dBCARGS                                                  \
   int i;                                                        \
   int width = var w, height = var h;                            \
   int srcType = var type;                                       \
   int srcLine = (( width * ( srcType & imBPP) + 31) / 32) * 4;  \
   int dstLine = (( width * ( dstType & imBPP) + 31) / 32) * 4;  \
   int dstColors  = ( 1 << ( dstType & imBPP)) & 0x1ff;          \
   int srcColors  = ( 1 << ( srcType & imBPP)) & 0x1ff;          \
   Byte * srcData = var data;                                    \
   Byte colorref[ 256]

#define BCWARN                                                   \
   (void)srcType; (void)srcLine; (void)dstLine; (void)srcColors; \
   (void)dstColors; (void)srcData; (void)colorref; (void)i;

#define BC(from,to,conv) void ic_##from##_##to##_ict##conv( Handle self, Byte * dstData, PRGBColor dstPal, int dstType)
#define BCCONV srcData, dstData, width
